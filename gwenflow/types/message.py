import json
from typing import Any, Callable, Dict, List, Literal, Optional, Tuple, Union

from pydantic import BaseModel, ConfigDict, field_validator, model_validator

SYSTEM = "system"
USER = "user"
ASSISTANT = "assistant"
TOOL = "tool"


class ContentItem(BaseModel):
    text: Optional[str] = None
    image: Optional[str] = None
    file: Optional[str] = None
    audio: Optional[Union[str, dict]] = None
    video: Optional[Union[str, list]] = None

    @model_validator(mode="after")
    def check_exclusivity(self):
        provided_fields = 0
        if self.text is not None:
            provided_fields += 1
        if self.image:
            provided_fields += 1
        if self.file:
            provided_fields += 1
        if self.audio:
            provided_fields += 1
        if self.video:
            provided_fields += 1

        if provided_fields != 1:
            raise ValueError("Exactly one of 'text', 'image', 'file', 'audio', or 'video' must be provided.")
        return self

    def __repr__(self):
        return f"ContentItem({self.model_dump()})"

    def get_type_and_value(self) -> Tuple[Literal["text", "image", "file", "audio", "video"], str]:
        ((t, v),) = self.model_dump().items()
        assert t in ("text", "image", "file", "audio", "video")
        return t, v

    @property
    def type(self) -> Literal["text", "image", "file", "audio", "video"]:
        t, v = self.get_type_and_value()
        return t

    @property
    def value(self) -> str:
        t, v = self.get_type_and_value()
        return v


class Message(BaseModel):
    """Base message class."""

    role: str
    """The role of the messages author (system, user, assistant or tool)."""

    content: Optional[Union[str, List[Union[str, dict]], List[ContentItem]]] = None
    """Content of the message."""

    name: Optional[str] = None
    """An optional name."""

    tool_call_id: Optional[str] = None
    """Tool call that this message is responding to."""

    tool_calls: Optional[List[Dict[str, Any]]] = None
    """The tool calls generated by the model, such as function calls."""

    thinking: Optional[str] = None
    """Legacy thinking content."""

    reasoning: Optional[str] = None
    """Native reasoning content from reasoning models."""

    extra: Optional[dict] = None

    model_config = ConfigDict(extra="allow", populate_by_name=True, arbitrary_types_allowed=True)

    def __repr__(self):
        return f"Message({self.model_dump()})"

    @field_validator("role")
    @classmethod
    def role_checker(cls, value: str) -> str:
        if value not in [USER, ASSISTANT, SYSTEM, TOOL]:
            raise ValueError(f"{value} must be one of {','.join([USER, ASSISTANT, SYSTEM, TOOL])}")
        return value

    @classmethod
    def extract_event_from_response_output(cls, response: Any, tool_executor: Callable) -> List["Message"]:
        messages = []

        global_reasoning = getattr(response.reasoning, "summary", None) if hasattr(response, "reasoning") else None

        accumulated_reasoning = []

        for item in response.output:
            if item.type == "reasoning":
                text = getattr(item, "summary", None)
                if text and text != "detailed" and text != "auto":
                    accumulated_reasoning.append(text)
        if accumulated_reasoning:
            global_reasoning = "\n".join(accumulated_reasoning)

        for item in response.output:
            if item.type == "function_call":
                tool_call = {"id": item.id, "function": {"name": item.name, "arguments": item.arguments}}
                execution_result = tool_executor(item.name, item.arguments)

                messages.append(
                    cls(role="assistant", tool_calls=[tool_call], content=execution_result, reasoning=global_reasoning)
                )

            elif item.type == "message":
                messages.append(cls(role="assistant", content=item.content, reasoning=global_reasoning))

        return messages

    def to_dict(self, **kwargs: Any) -> Dict[str, Any]:
        message_dict = self.model_dump(**kwargs)
        message_dict = {
            k: v for k, v in message_dict.items() if v is not None and not (isinstance(v, (list, dict)) and len(v) == 0)
        }
        return message_dict

    def to_openai_chat_completion(self) -> Dict[str, Any]:
        """Format a message into the format expected by OpenAI Chat Completion."""
        message_dict: Dict[str, Any] = {
            "role": self.role,
            "content": self.content,
            "name": self.name,
            "tool_call_id": self.tool_call_id,
            "tool_calls": self.tool_calls,
        }
        message_dict = {k: v for k, v in message_dict.items() if v is not None}

        if self.tool_calls is not None and len(self.tool_calls) == 0:
            message_dict["tool_calls"] = None

        return message_dict

    def _safe_serialize(self, obj: Any) -> str:
        try:
            if hasattr(obj, "model_dump_json"):
                return obj.model_dump_json()
            if hasattr(obj, "dict"):
                return json.dumps(obj.dict(), default=str)
            return str(obj)
        except Exception:
            return str(obj)

    def to_openai_response(self) -> List[Dict[str, Any]]:
        items = []

        if self.tool_calls:
            for tc in self.tool_calls:
                items.append(
                    {
                        "type": "function_call",
                        "call_id": tc.get("id"),
                        "name": tc["function"]["name"],
                        "arguments": tc["function"]["arguments"],
                    }
                )

        if self.role == "tool" or (self.tool_calls and self.content):
            call_id = self.tool_call_id
            if not call_id and self.tool_calls:
                call_id = self.tool_calls[0]["id"]
            items.append(
                {"type": "function_call_output", "call_id": call_id, "output": self._safe_serialize(self.content)}
            )

        if not items and self.content:
            if self.role == "user":
                items.append(
                    {"role": "user", "type": "message", "content": [{"type": "input_text", "text": str(self.content)}]}
                )
            elif self.role == "assistant":
                items.append(
                    {
                        "role": "assistant",
                        "type": "message",
                        "content": [{"type": "output_text", "text": str(self.content)}],
                    }
                )

        return items
